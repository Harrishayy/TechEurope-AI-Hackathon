<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vision Annotator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* ── Top bar ─────────────────────────────────────────── */
    header {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.85rem 1.5rem;
      border-bottom: 1px solid #1e293b;
    }
    header h1 {
      font-size: 1.1rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: #f1f5f9;
    }
    #status {
      font-size: 0.78rem;
      color: #64748b;
    }

    /* ── Main column ─────────────────────────────────────── */
    .app {
      width: 100%;
      max-width: 860px;
      padding: 1rem 1rem 2rem;
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    /* ── Camera + overlays ───────────────────────────────── */
    #camera-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      background: #000;
      border-radius: 12px 12px 0 0;
      overflow: hidden;
    }

    #video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    #overlay-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* Description/result overlay at bottom of camera */
    #camera-description {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0,0,0,0.88));
      padding: 2.5rem 1rem 0.9rem;
      font-size: 0.83rem;
      line-height: 1.55;
      color: #e2e8f0;
      z-index: 11;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    #camera-description.visible { opacity: 1; }
    #camera-description .obj-count {
      display: block;
      margin-top: 0.25rem;
      font-size: 0.72rem;
      color: #94a3b8;
    }

    /* Loading spinner inside camera */
    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: #e2e8f0;
      gap: 0.5rem;
      z-index: 20;
    }
    .spinner {
      width: 18px; height: 18px;
      border: 2px solid #475569;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ── Tutorial bar (directly below camera, no gap) ────── */
    .tutorial-bar {
      background: #1e293b;
      border-left: 1px solid #334155;
      border-right: 1px solid #334155;
      padding: 0.6rem 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .tutorial-bar input[type="text"] {
      flex: 1;
      padding: 0.45rem 0.7rem;
      background: #0f172a;
      color: #e2e8f0;
      border: 1px solid #334155;
      border-radius: 6px;
      font-size: 0.85rem;
      outline: none;
      transition: border-color 0.15s;
      min-width: 0;
    }
    .tutorial-bar input[type="text"]:focus { border-color: #3b82f6; }
    .tutorial-bar input[type="text"]::placeholder { color: #475569; }
    .tutorial-bar input[type="text"]:disabled { opacity: 0.45; cursor: not-allowed; }

    /* ── Step instruction strip ──────────────────────────── */
    #step-strip {
      background: #1a2744;
      border-left: 1px solid #334155;
      border-right: 1px solid #334155;
      padding: 0.7rem 1rem;
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 0.2rem;
    }
    .step-counter {
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #475569;
    }
    .step-instruction {
      font-size: 0.95rem;
      line-height: 1.55;
      color: #f1f5f9;
    }
    .step-placeholder {
      font-size: 0.85rem;
      color: #475569;
      font-style: italic;
    }

    /* ── Bottom controls bar ─────────────────────────────── */
    .controls-bar {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 0 0 12px 12px;
      padding: 0.6rem 0.75rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    /* ── Buttons ─────────────────────────────────────────── */
    button {
      padding: 0.48rem 0.9rem;
      border: none;
      border-radius: 6px;
      font-size: 0.82rem;
      font-weight: 500;
      cursor: pointer;
      background: #3b82f6;
      color: #fff;
      transition: background 0.15s, opacity 0.15s;
      user-select: none;
      -webkit-user-select: none;
      white-space: nowrap;
    }
    button:disabled { background: #334155; color: #64748b; cursor: not-allowed; }
    button:hover:not(:disabled) { background: #2563eb; }
    button:active:not(:disabled) { background: #1d4ed8; }

    #btn-start { background: #22c55e; }
    #btn-start:hover:not(:disabled) { background: #16a34a; }
    #btn-start.running { background: #ef4444; }
    #btn-start.running:hover:not(:disabled) { background: #dc2626; }

    #btn-next { background: #0ea5e9; }
    #btn-next:hover:not(:disabled) { background: #0284c7; }

    #btn-voice { background: #475569; }
    #btn-voice:hover:not(:disabled) { background: #334155; }
    #btn-voice.listening { background: #ef4444; }

    #btn-analyze { background: #475569; }
    #btn-analyze:hover:not(:disabled) { background: #334155; }

    #btn-mute { background: #334155; font-size: 0.78rem; }
    #btn-mute:hover:not(:disabled) { background: #475569; }
    #btn-mute.muted { background: #7c3aed; }

    .transcript-box {
      font-style: italic;
      font-size: 0.78rem;
      color: #94a3b8;
      flex: 1;
      min-width: 60px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* ── Tracking status ─────────────────────────────────── */
    .tracking-badge {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.75rem;
      color: #64748b;
      white-space: nowrap;
    }
    .tracking-dot {
      width: 7px; height: 7px;
      border-radius: 50%;
      background: #475569;
      flex-shrink: 0;
    }
    .tracking-dot.active {
      background: #22c55e;
      animation: pulse-dot 1.2s ease-in-out infinite;
    }
    @keyframes pulse-dot {
      0%,100% { opacity:1; transform:scale(1); }
      50%      { opacity:0.5; transform:scale(0.7); }
    }
  </style>
</head>
<body>

<header>
  <h1>Vision Annotator</h1>
  <span id="status">Requesting camera…</span>
</header>

<div class="app">

  <!-- ── Camera ──────────────────────────────────────────── -->
  <div id="camera-wrapper">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay-canvas"></canvas>
    <div id="camera-description"></div>
  </div>

  <!-- ── Tutorial topic + start/next inline with camera ─── -->
  <div class="tutorial-bar">
    <input
      type="text"
      id="topic-input"
      placeholder="What do you want to learn? (e.g. open a can, use a coffee machine)"
      autocomplete="off"
    />
    <button id="btn-start"  disabled>Start</button>
    <button id="btn-next"   disabled>Next  ⎵</button>
  </div>

  <!-- ── Current step instruction ──────────────────────── -->
  <div id="step-strip">
    <span class="step-placeholder">Enter a topic above and press Start — or just point the camera and click Analyze.</span>
  </div>

  <!-- ── Bottom controls ───────────────────────────────── -->
  <div class="controls-bar">
    <button id="btn-analyze" disabled>Analyze Frame</button>
    <button id="btn-voice"   disabled>Hold to Speak</button>
    <span   id="transcript"  class="transcript-box"></span>
    <span class="tracking-badge">
      <span class="tracking-dot" id="tracking-dot"></span>
      <span id="tracking-status">Not tracking</span>
    </span>
    <button id="btn-mute">Voice: On</button>
  </div>

</div><!-- .app -->

<script>
// ═══════════════════════════════════════════════════════════════════════════
// State
// ═══════════════════════════════════════════════════════════════════════════
const state = {
  stream:          null,
  isAnalyzing:     false,
  recognition:     null,
  voiceTranscript: "",
  voiceMuted:      false,
  descFadeTimer:   null,
};

const tut = {
  topic:              "",
  completedSteps:     [],
  currentDescription: "",
  currentTarget:      "",
  currentAction:      "",   // short_action from LLM, shown on annotation
  currentHint:        "",
  stepNumber:         0,
  isRunning:          false,
  isGenerating:       false,
  target:  { x: 0, y: 0, w: 0, h: 0 },
  current: { x: 0, y: 0, w: 0, h: 0 },
  analysisInterval: null,
  rafId:            null,
};

// ═══════════════════════════════════════════════════════════════════════════
// DOM
// ═══════════════════════════════════════════════════════════════════════════
const video         = document.getElementById("video");
const overlayCanvas = document.getElementById("overlay-canvas");
const overlayCtx    = overlayCanvas.getContext("2d");
const cameraDesc    = document.getElementById("camera-description");
const cameraWrapper = document.getElementById("camera-wrapper");
const statusEl      = document.getElementById("status");
const topicInput    = document.getElementById("topic-input");
const stepStrip     = document.getElementById("step-strip");
const btnStart      = document.getElementById("btn-start");
const btnNext       = document.getElementById("btn-next");
const btnAnalyze    = document.getElementById("btn-analyze");
const btnVoice      = document.getElementById("btn-voice");
const btnMute       = document.getElementById("btn-mute");
const transcriptEl  = document.getElementById("transcript");
const trackingDot   = document.getElementById("tracking-dot");
const trackingStatus= document.getElementById("tracking-status");

// ═══════════════════════════════════════════════════════════════════════════
// Step display helpers
// ═══════════════════════════════════════════════════════════════════════════
function showStep() {
  stepStrip.innerHTML = `
    <span class="step-counter">Step ${tut.stepNumber}</span>
    <span class="step-instruction">${escapeHtml(tut.currentDescription)}</span>
  `;
}
function showGenerating() {
  stepStrip.innerHTML = `
    <span class="step-counter">Thinking…</span>
    <span class="step-placeholder">Generating next step…</span>
  `;
}
function showPlaceholder(text, color) {
  stepStrip.innerHTML = `<span class="step-placeholder" style="${color ? `color:${color}` : ""}">${escapeHtml(text)}</span>`;
}

// ═══════════════════════════════════════════════════════════════════════════
// Generate next step from LLM
// ═══════════════════════════════════════════════════════════════════════════
async function generateNextStep() {
  if (tut.isGenerating) return;
  tut.isGenerating = true;
  showGenerating();

  // Clear stale annotation immediately
  tut.target  = { x: 0, y: 0, w: 0, h: 0 };
  tut.current = { x: 0, y: 0, w: 0, h: 0 };
  tut.currentTarget = "";
  tut.currentAction = "";
  tut.currentHint   = "";

  try {
    const res = await fetch("/generate-step", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ topic: tut.topic, completed_steps: tut.completedSteps }),
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    if (data.is_complete) {
      speakText("Tutorial complete! You have covered all the steps.");
      stopTutorial();
      showPlaceholder("Tutorial complete! Great job.", "#22c55e");
      return;
    }

    tut.currentDescription = data.step_description;
    tut.currentTarget      = data.target_object;
    tut.currentAction      = data.short_action || "";
    tut.currentHint        = data.hint || "";

    showStep();
    speakText(data.step_description);
    statusEl.textContent = `Tracking: ${data.target_object}`;
  } catch (err) {
    showPlaceholder(`Error: ${err.message}`, "#f87171");
    console.error("generateNextStep:", err);
  } finally {
    tut.isGenerating = false;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Start / Stop / Next
// ═══════════════════════════════════════════════════════════════════════════
async function startTutorial() {
  const topic = topicInput.value.trim();
  if (!topic) return;

  tut.topic          = topic;
  tut.completedSteps = [];
  tut.stepNumber     = 1;
  tut.isRunning      = true;

  btnStart.textContent = "Stop";
  btnStart.classList.add("running");
  btnNext.disabled     = false;
  topicInput.disabled  = true;
  btnAnalyze.disabled  = true;

  clearQuickAnnotations();
  startRenderLoop();
  startTrackingLoop();
  await generateNextStep();
}

function stopTutorial() {
  tut.isRunning    = false;
  tut.isGenerating = false;

  clearInterval(tut.analysisInterval); tut.analysisInterval = null;
  cancelAnimationFrame(tut.rafId);     tut.rafId = null;

  overlayCanvas.width  = overlayCanvas.clientWidth;
  overlayCanvas.height = overlayCanvas.clientHeight;
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  btnStart.textContent = "Start";
  btnStart.classList.remove("running");
  btnNext.disabled     = true;
  topicInput.disabled  = false;
  if (state.stream) btnAnalyze.disabled = false;

  trackingDot.classList.remove("active");
  trackingStatus.textContent = "Not tracking";
  showPlaceholder("Tutorial stopped. Edit the topic and press Start again.");
}

async function nextStep() {
  if (!tut.isRunning || tut.isGenerating) return;
  if (tut.currentDescription) tut.completedSteps.push(tut.currentDescription);
  tut.stepNumber++;
  await generateNextStep();
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial tracking loop — polls /analyze-step every 600 ms
// ═══════════════════════════════════════════════════════════════════════════
function startTrackingLoop() {
  clearInterval(tut.analysisInterval);

  const poll = async () => {
    if (!tut.isRunning || !state.stream) return;
    if (!tut.currentTarget || tut.isGenerating) return;

    const off = document.createElement("canvas");
    off.width  = video.videoWidth  || 640;
    off.height = video.videoHeight || 480;
    off.getContext("2d").drawImage(video, 0, 0);
    const b64 = off.toDataURL("image/jpeg", 0.75).split(",")[1];

    try {
      const res = await fetch("/analyze-step", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image:            b64,
          target_object:    tut.currentTarget,
          step_instruction: tut.currentDescription,
          hint:             tut.currentHint,
          width: off.width, height: off.height,
        }),
      });
      if (!res.ok) return;
      const data = await res.json();

      if (data.found && data.box_2d) {
        const [ymin, xmin, ymax, xmax] = data.box_2d;
        if (xmax - xmin < 5 || ymax - ymin < 5) return;
        tut.target = { x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin };
        trackingDot.classList.add("active");
        trackingStatus.textContent = `Tracking: ${escapeHtml(data.label || tut.currentTarget)}`;
      } else {
        trackingDot.classList.remove("active");
        trackingStatus.textContent = "Searching…";
      }
    } catch (e) { console.warn("poll:", e.message); }
  };

  poll();
  tut.analysisInterval = setInterval(poll, 600);
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial render loop — lerp + AR bracket + action label
// ═══════════════════════════════════════════════════════════════════════════
function startRenderLoop() {
  cancelAnimationFrame(tut.rafId);

  const LERP = 0.12;
  const lerp  = (a, b, t) => a + (b - a) * t;

  function frame() {
    if (!tut.isRunning) return;
    tut.rafId = requestAnimationFrame(frame);

    // Keep canvas pixel-perfect with CSS size
    if (overlayCanvas.width  !== overlayCanvas.clientWidth ||
        overlayCanvas.height !== overlayCanvas.clientHeight) {
      overlayCanvas.width  = overlayCanvas.clientWidth;
      overlayCanvas.height = overlayCanvas.clientHeight;
    }
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    // Lerp current toward target
    const tgt = tut.target, cur = tut.current;
    cur.x = lerp(cur.x, tgt.x, LERP);
    cur.y = lerp(cur.y, tgt.y, LERP);
    cur.w = lerp(cur.w, tgt.w, LERP);
    cur.h = lerp(cur.h, tgt.h, LERP);
    if (tgt.w < 5 && tgt.h < 5) return;

    const cw = overlayCanvas.width, ch = overlayCanvas.height;
    const px = (cur.x / 1000) * cw, py = (cur.y / 1000) * ch;
    const pw = (cur.w / 1000) * cw, ph = (cur.h / 1000) * ch;

    const t     = Date.now() / 800;
    const pulse = 0.65 + 0.35 * Math.sin(t * Math.PI * 2);
    const glow  = 0.10 + 0.15 * Math.sin(t * Math.PI * 2 + 1);

    overlayCtx.save();

    // Glow fill
    overlayCtx.fillStyle = `rgba(56, 189, 248, ${glow})`;
    overlayCtx.fillRect(px, py, pw, ph);

    // Corner brackets
    const bLen = Math.min(pw * 0.22, ph * 0.22, 28);
    overlayCtx.strokeStyle = `rgba(56, 189, 248, ${pulse})`;
    overlayCtx.lineWidth = 2.5;
    overlayCtx.lineCap   = "square";
    const corner = (cx, cy, dx, dy) => {
      overlayCtx.beginPath();
      overlayCtx.moveTo(cx + dx * bLen, cy);
      overlayCtx.lineTo(cx, cy);
      overlayCtx.lineTo(cx, cy + dy * bLen);
      overlayCtx.stroke();
    };
    corner(px,      py,       1,  1);
    corner(px + pw, py,      -1,  1);
    corner(px,      py + ph,  1, -1);
    corner(px + pw, py + ph, -1, -1);

    // Arrow from upper-left to center
    const cx = px + pw / 2, cy = py + ph / 2;
    const sx = px - 36,     sy = py - 36;
    const angle = Math.atan2(cy - sy, cx - sx);
    const hl    = 11;
    overlayCtx.strokeStyle = `rgba(56, 189, 248, ${pulse * 0.9})`;
    overlayCtx.lineWidth   = 2;
    overlayCtx.lineCap     = "round";
    overlayCtx.beginPath(); overlayCtx.moveTo(sx, sy); overlayCtx.lineTo(cx, cy); overlayCtx.stroke();
    overlayCtx.strokeStyle = `rgba(56, 189, 248, ${pulse})`;
    overlayCtx.beginPath();
    overlayCtx.moveTo(cx, cy);
    overlayCtx.lineTo(cx - hl * Math.cos(angle - Math.PI/7), cy - hl * Math.sin(angle - Math.PI/7));
    overlayCtx.moveTo(cx, cy);
    overlayCtx.lineTo(cx - hl * Math.cos(angle + Math.PI/7), cy - hl * Math.sin(angle + Math.PI/7));
    overlayCtx.stroke();

    // ── Label badge with optional action line ────────────
    const labelText  = tut.currentTarget || "";
    const actionText = tut.currentAction  || "";
    const fs         = Math.max(11, Math.min(14, pw * 0.09));
    const afs        = Math.max(10, fs - 1);

    overlayCtx.font = `bold ${fs}px system-ui, sans-serif`;
    const lw = overlayCtx.measureText(labelText).width;
    overlayCtx.font = `${afs}px system-ui, sans-serif`;
    const aw = actionText ? overlayCtx.measureText("→ " + actionText).width : 0;

    const badgeW = Math.max(lw, aw) + 16;
    const badgeH = actionText ? (fs + afs + 14) : (fs + 10);
    const badgeX = Math.max(2, Math.min(cw - badgeW - 2, px + pw / 2 - badgeW / 2));
    const badgeY = (py - badgeH - 8 >= 0) ? py - badgeH - 8 : py + ph + 8;

    overlayCtx.fillStyle = "rgba(15, 23, 42, 0.90)";
    overlayCtx.beginPath();
    overlayCtx.roundRect(badgeX, badgeY, badgeW, badgeH, 5);
    overlayCtx.fill();

    // Label (cyan)
    overlayCtx.font      = `bold ${fs}px system-ui, sans-serif`;
    overlayCtx.fillStyle = `rgba(56, 189, 248, ${pulse})`;
    overlayCtx.fillText(labelText, badgeX + 8, badgeY + fs + 4);

    // Action (amber)
    if (actionText) {
      overlayCtx.font      = `${afs}px system-ui, sans-serif`;
      overlayCtx.fillStyle = `rgba(251, 191, 36, ${pulse * 0.95})`;
      overlayCtx.fillText("→ " + actionText, badgeX + 8, badgeY + fs + afs + 10);
    }

    overlayCtx.restore();
  }
  frame();
}

// ═══════════════════════════════════════════════════════════════════════════
// Camera init
// ═══════════════════════════════════════════════════════════════════════════
async function initCamera() {
  try {
    state.stream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "environment" },
      audio: false,
    });
    video.srcObject = state.stream;
    await video.play();
    btnAnalyze.disabled  = false;
    btnVoice.disabled    = false;
    statusEl.textContent = "Camera ready.";
  } catch (err) {
    statusEl.textContent =
      err.name === "NotAllowedError" ? "Camera permission denied." :
      err.name === "NotFoundError"   ? "No camera found." :
      `Camera error: ${err.message}`;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Quick analyze (capture frame → /analyze → draw on live camera)
// ═══════════════════════════════════════════════════════════════════════════
function captureFrame() {
  if (!state.stream || state.isAnalyzing || tut.isRunning) return;

  const off = document.createElement("canvas");
  off.width  = video.videoWidth  || 640;
  off.height = video.videoHeight || 480;
  off.getContext("2d").drawImage(video, 0, 0);
  analyzeFrame(off.toDataURL("image/jpeg", 0.85).split(",")[1], off.width, off.height);
}

async function analyzeFrame(b64, origW, origH) {
  state.isAnalyzing   = true;
  btnAnalyze.disabled = true;
  btnVoice.disabled   = true;

  const spinner = document.createElement("div");
  spinner.className = "loading-overlay";
  spinner.innerHTML = '<div class="spinner"></div><span>Analyzing…</span>';
  cameraWrapper.appendChild(spinner);
  statusEl.textContent = "Analyzing…";

  try {
    const res = await fetch("/analyze", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ image: b64, prompt: state.voiceTranscript, width: origW, height: origH }),
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({ detail: `HTTP ${res.status}` }));
      throw new Error(err.detail || `HTTP ${res.status}`);
    }
    const data = await res.json();
    drawAnalysisAnnotations(data);
    statusEl.textContent = `${data.objects.length} component(s) detected.`;
  } catch (err) {
    statusEl.textContent = `Error: ${err.message}`;
    console.error(err);
  } finally {
    state.isAnalyzing     = false;
    btnAnalyze.disabled   = false;
    btnVoice.disabled     = false;
    state.voiceTranscript = "";
    transcriptEl.textContent = "";
    spinner.remove();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Draw quick-analyze annotations on the live camera overlay canvas
// ═══════════════════════════════════════════════════════════════════════════
const BOX_COLORS = [
  "#3b82f6","#ef4444","#22c55e","#f59e0b","#a855f7",
  "#06b6d4","#f97316","#84cc16","#ec4899","#14b8a6",
];

function drawAnalysisAnnotations(data) {
  overlayCanvas.width  = overlayCanvas.clientWidth;
  overlayCanvas.height = overlayCanvas.clientHeight;
  const cw = overlayCanvas.width, ch = overlayCanvas.height;
  overlayCtx.clearRect(0, 0, cw, ch);

  data.objects.forEach((obj, i) => {
    const [yn, xn, ym, xm] = obj.box_2d;
    const x = (xn / 1000) * cw, y = (yn / 1000) * ch;
    const w = ((xm - xn) / 1000) * cw, h = ((ym - yn) / 1000) * ch;
    const color = BOX_COLORS[i % BOX_COLORS.length];

    // Box
    overlayCtx.strokeStyle = color;
    overlayCtx.lineWidth   = 2.5;
    overlayCtx.strokeRect(x, y, w, h);

    // Label badge
    const fs = 12;
    overlayCtx.font = `bold ${fs}px system-ui`;
    const tw = overlayCtx.measureText(obj.label).width;
    const bh = fs + 6;
    const by = y - bh - 2 >= 0 ? y - bh - 2 : y + 2;

    overlayCtx.fillStyle = color;
    overlayCtx.beginPath();
    overlayCtx.roundRect(x, by, tw + 10, bh, 3);
    overlayCtx.fill();

    overlayCtx.fillStyle = "#fff";
    overlayCtx.fillText(obj.label, x + 5, by + fs);
  });

  // Description overlay on camera
  cameraDesc.innerHTML = `${escapeHtml(data.description)}<span class="obj-count">${data.objects.length} component(s) highlighted</span>`;
  cameraDesc.classList.add("visible");
  if (!state.voiceMuted) speakText(data.description);

  clearTimeout(state.descFadeTimer);
  state.descFadeTimer = setTimeout(clearQuickAnnotations, 10000);
}

function clearQuickAnnotations() {
  clearTimeout(state.descFadeTimer);
  state.descFadeTimer = null;
  cameraDesc.classList.remove("visible");
  if (!tut.isRunning) overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
}

function escapeHtml(s) {
  return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

// ═══════════════════════════════════════════════════════════════════════════
// Voice input (push-to-talk → auto-analyze on release)
// ═══════════════════════════════════════════════════════════════════════════
function initVoiceInput() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { btnVoice.disabled = true; btnVoice.title = "Not supported"; return; }

  const rec = new SR();
  rec.continuous = false; rec.interimResults = true; rec.lang = "en-US";
  state.recognition = rec;

  rec.onresult = (event) => {
    let interim = "", final = "";
    for (const r of event.results) {
      if (r.isFinal) final += r[0].transcript; else interim += r[0].transcript;
    }
    transcriptEl.textContent = final || interim;

    if (final) {
      const t = final.trim().toLowerCase();
      if (tut.isRunning) {
        if (/\bnext\b/.test(t)) { nextStep(); state.voiceTranscript = ""; return; }
      } else {
        if (/\bstart\b/.test(t) && topicInput.value.trim()) { startTutorial(); state.voiceTranscript = ""; return; }
        // Otherwise treat as topic AND as prompt for quick analyze
        topicInput.value = final.trim();
        btnStart.disabled = false;
        state.voiceTranscript = final.trim();
        return;
      }
      state.voiceTranscript = final.trim();
    }
  };

  rec.onend = () => {
    btnVoice.textContent = "Hold to Speak";
    btnVoice.classList.remove("listening");
    // Auto-analyze on release when not in tutorial mode
    if (state.voiceTranscript && !tut.isRunning && !state.isAnalyzing) captureFrame();
  };

  rec.onerror = (e) => {
    transcriptEl.textContent = `Error: ${e.error}`;
    btnVoice.textContent = "Hold to Speak";
    btnVoice.classList.remove("listening");
  };

  const start = (e) => {
    e.preventDefault();
    state.voiceTranscript = "";
    transcriptEl.textContent = "Listening…";
    btnVoice.textContent = "Recording…";
    btnVoice.classList.add("listening");
    try { rec.start(); } catch (_) {}
  };
  const stop = (e) => { e.preventDefault(); rec.stop(); };

  btnVoice.addEventListener("mousedown",  start);
  btnVoice.addEventListener("touchstart", start, { passive: false });
  btnVoice.addEventListener("mouseup",    stop);
  btnVoice.addEventListener("mouseleave", stop);
  btnVoice.addEventListener("touchend",   stop);
}

// ═══════════════════════════════════════════════════════════════════════════
// Voice output
// ═══════════════════════════════════════════════════════════════════════════
function speakText(text) {
  if (!window.speechSynthesis || !text || state.voiceMuted) return;
  window.speechSynthesis.cancel();
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "en-US"; u.rate = 1.0;
  u.onpause = () => { if (window.speechSynthesis.paused) window.speechSynthesis.resume(); };
  const go = () => {
    const preferred = window.speechSynthesis.getVoices().find(v =>
      v.name.includes("Google US English") || v.name === "Alex" || (v.lang === "en-US" && v.localService)
    );
    if (preferred) u.voice = preferred;
    window.speechSynthesis.speak(u);
  };
  window.speechSynthesis.getVoices().length > 0 ? go() : (window.speechSynthesis.onvoiceschanged = () => { window.speechSynthesis.onvoiceschanged = null; go(); });
}

// ═══════════════════════════════════════════════════════════════════════════
// Event wiring
// ═══════════════════════════════════════════════════════════════════════════
btnMute.addEventListener("click", () => {
  state.voiceMuted = !state.voiceMuted;
  window.speechSynthesis?.cancel();
  btnMute.textContent = state.voiceMuted ? "Voice: Off" : "Voice: On";
  btnMute.classList.toggle("muted", state.voiceMuted);
});

btnAnalyze.addEventListener("click", captureFrame);

topicInput.addEventListener("input", (e) => { btnStart.disabled = !e.target.value.trim(); });
topicInput.addEventListener("keydown", (e) => { if (e.key === "Enter" && topicInput.value.trim()) startTutorial(); });

btnStart.addEventListener("click", () => { tut.isRunning ? stopTutorial() : startTutorial(); });
btnNext.addEventListener("click",  nextStep);

document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && tut.isRunning) {
    const tag = document.activeElement.tagName;
    if (tag !== "INPUT" && tag !== "SELECT" && tag !== "TEXTAREA") { e.preventDefault(); nextStep(); }
  }
});

// ═══════════════════════════════════════════════════════════════════════════
// Boot
// ═══════════════════════════════════════════════════════════════════════════
document.addEventListener("DOMContentLoaded", async () => {
  await initCamera();
  initVoiceInput();
});
</script>
</body>
</html>
