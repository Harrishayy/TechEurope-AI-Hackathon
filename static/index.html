<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vision Annotator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      text-align: center;
      padding: 1.25rem 1rem 1rem;
      border-bottom: 1px solid #1e293b;
    }
    header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: #f1f5f9;
    }
    #status {
      font-size: 0.8rem;
      color: #64748b;
      margin-top: 0.25rem;
    }

    .workspace {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.25rem;
      padding: 1.25rem;
      flex: 1;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
    }

    .panel {
      background: #1e293b;
      border-radius: 12px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .panel h2 {
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #94a3b8;
    }

    /* ── Video / Canvas wrappers ─────────────────────────── */
    .media-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 4 / 3;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
    }

    #video, #captured-img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    #captured-img { display: none; }

    #annotation-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .loading-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: #e2e8f0;
      gap: 0.5rem;
      border-radius: 8px;
    }
    .spinner {
      width: 18px; height: 18px;
      border: 2px solid #475569;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ── Controls ────────────────────────────────────────── */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    button {
      padding: 0.55rem 1rem;
      border: none;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      background: #3b82f6;
      color: #fff;
      transition: background 0.15s, opacity 0.15s;
      user-select: none;
      -webkit-user-select: none;
    }
    button:disabled { background: #334155; color: #64748b; cursor: not-allowed; }
    button:hover:not(:disabled) { background: #2563eb; }
    button:active:not(:disabled) { background: #1d4ed8; }

    #btn-voice { background: #475569; }
    #btn-voice:hover:not(:disabled) { background: #334155; }
    #btn-voice.listening { background: #ef4444; }
    #btn-voice.listening:hover { background: #dc2626; }

    #btn-mute { background: #475569; font-size: 0.8rem; }
    #btn-mute:hover:not(:disabled) { background: #334155; }
    #btn-mute.muted { background: #7c3aed; }

    .transcript-box {
      font-style: italic;
      font-size: 0.8rem;
      color: #94a3b8;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* ── Description box ─────────────────────────────────── */
    .description {
      font-size: 0.875rem;
      line-height: 1.65;
      padding: 0.75rem;
      background: #0f172a;
      border-radius: 8px;
      min-height: 80px;
      color: #cbd5e1;
    }
    .description small {
      display: block;
      margin-top: 0.4rem;
      color: #475569;
      font-size: 0.75rem;
    }
    .error-text { color: #f87171; }

    @media (max-width: 768px) {
      .workspace { grid-template-columns: 1fr; }
    }

    /* ── Tutorial overlay canvas on live video ───────────── */
    #tutorial-overlay-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
    }

    /* ── Tutorial panel ──────────────────────────────────── */
    .tutorial-topic-selector {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .tutorial-topic-selector label {
      font-size: 0.8rem;
      color: #94a3b8;
      white-space: nowrap;
    }
    .tutorial-topic-selector input[type="text"] {
      flex: 1;
      padding: 0.4rem 0.6rem;
      background: #0f172a;
      color: #e2e8f0;
      border: 1px solid #334155;
      border-radius: 6px;
      font-size: 0.85rem;
      outline: none;
      transition: border-color 0.15s;
    }
    .tutorial-topic-selector input[type="text"]:focus {
      border-color: #3b82f6;
    }
    .tutorial-topic-selector input[type="text"]::placeholder {
      color: #475569;
    }
    .tutorial-topic-selector input[type="text"]:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .tutorial-step-display {
      background: #0f172a;
      border-radius: 8px;
      padding: 1rem;
      min-height: 100px;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      flex: 1;
    }
    .tutorial-step-counter {
      font-size: 0.75rem;
      color: #475569;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .tutorial-step-instruction {
      font-size: 1rem;
      line-height: 1.6;
      color: #f1f5f9;
    }
    .tutorial-step-placeholder {
      font-size: 0.875rem;
      color: #475569;
      font-style: italic;
    }

    .tutorial-controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }
    #btn-tutorial-start { background: #22c55e; }
    #btn-tutorial-start:hover:not(:disabled) { background: #16a34a; }
    #btn-tutorial-start.running { background: #ef4444; }
    #btn-tutorial-start.running:hover:not(:disabled) { background: #dc2626; }

    .tutorial-status-badge {
      font-size: 0.75rem;
      color: #64748b;
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }
    .tracking-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #475569;
      flex-shrink: 0;
    }
    .tracking-dot.active {
      background: #22c55e;
      animation: pulse-dot 1.2s ease-in-out infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50%       { opacity: 0.55; transform: scale(0.75); }
    }
  </style>
</head>
<body>

<header>
  <h1>Vision Annotator</h1>
  <p id="status">Requesting camera access…</p>
</header>

<main class="workspace">

  <!-- ── Left panel: live camera ──────────────────────────── -->
  <section class="panel">
    <h2>Live Camera</h2>
    <div class="media-wrapper" id="camera-wrapper">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="tutorial-overlay-canvas"></canvas>
    </div>
    <div class="controls">
      <button id="btn-capture" disabled>Capture &amp; Analyze</button>
      <button id="btn-voice"   disabled title="Hold to speak a custom prompt">Hold to Speak</button>
      <span   id="transcript" class="transcript-box"></span>
    </div>
  </section>

  <!-- ── Right panel: tutorial ────────────────────────────── -->
  <section class="panel">
    <h2>Tutorial</h2>

    <div class="tutorial-topic-selector">
      <label for="tutorial-topic-input">Topic:</label>
      <input
        type="text"
        id="tutorial-topic-input"
        placeholder="e.g. how to use a coffee machine"
        autocomplete="off"
      />
    </div>

    <div class="tutorial-step-display" id="tutorial-step-display">
      <span class="tutorial-step-placeholder">Select a topic and press Start to begin.</span>
    </div>

    <div class="tutorial-controls">
      <button id="btn-tutorial-start" disabled>Start Tutorial</button>
      <button id="btn-tutorial-next"  disabled>Next Step (Space)</button>
      <span class="tutorial-status-badge">
        <span class="tracking-dot" id="tracking-dot"></span>
        <span id="tracking-status">Not tracking</span>
      </span>
    </div>

    <div class="controls" style="margin-top: 0.25rem;">
      <button id="btn-mute" title="Toggle voice output">Voice: On</button>
    </div>

    <!-- Capture & Analyze output — visible, stacks below tutorial controls -->
    <div class="media-wrapper" id="output-wrapper">
      <img    id="captured-img" alt="Captured frame" />
      <canvas id="annotation-canvas"></canvas>
    </div>
    <div id="description-box" class="description">
      <p>Capture a frame to see analysis…</p>
    </div>
  </section>

</main>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// State
// ═══════════════════════════════════════════════════════════════════════════
const state = {
  stream:          null,
  isAnalyzing:     false,
  recognition:     null,
  voiceTranscript: "",
  voiceMuted:      false,
};

const tutorialState = {
  topic:              "",      // free-form user input
  completedSteps:     [],      // step_description strings of finished steps
  currentDescription: "",      // what the current step says (spoken + shown)
  currentTarget:      "",      // what Gemini is tracking right now
  currentHint:        "",      // spatial hint for the tracker
  stepNumber:         0,       // 1-based display counter
  isRunning:          false,
  isGenerating:       false,   // true while /generate-step is in flight
  target:           { x: 0, y: 0, w: 0, h: 0 },
  current:          { x: 0, y: 0, w: 0, h: 0 },
  analysisInterval: null,
  rafId:            null,
  lastFoundBox:     null,
};

// ═══════════════════════════════════════════════════════════════════════════
// DOM
// ═══════════════════════════════════════════════════════════════════════════
const video              = document.getElementById("video");
const btnCapture         = document.getElementById("btn-capture");
const btnVoice           = document.getElementById("btn-voice");
const btnMute            = document.getElementById("btn-mute");
const transcriptEl       = document.getElementById("transcript");
const capturedImg        = document.getElementById("captured-img");
const canvas             = document.getElementById("annotation-canvas");
const ctx                = canvas.getContext("2d");
const descBox            = document.getElementById("description-box");
const statusEl           = document.getElementById("status");
const outputWrapper      = document.getElementById("output-wrapper");

// Tutorial DOM refs
const tutorialTopicInput  = document.getElementById("tutorial-topic-input");
const tutorialStepDisplay = document.getElementById("tutorial-step-display");
const btnTutorialStart    = document.getElementById("btn-tutorial-start");
const btnTutorialNext     = document.getElementById("btn-tutorial-next");
const trackingDot         = document.getElementById("tracking-dot");
const trackingStatus      = document.getElementById("tracking-status");
const tutorialCanvas      = document.getElementById("tutorial-overlay-canvas");
const tutorialCtx         = tutorialCanvas.getContext("2d");

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial — step UI
// ═══════════════════════════════════════════════════════════════════════════
function updateStepUI() {
  tutorialStepDisplay.innerHTML = `
    <span class="tutorial-step-counter">Step ${tutorialState.stepNumber}</span>
    <span class="tutorial-step-instruction">${escapeHtml(tutorialState.currentDescription)}</span>
  `;
}

function showGenerating() {
  tutorialStepDisplay.innerHTML = `
    <span class="tutorial-step-counter">Thinking…</span>
    <span class="tutorial-step-placeholder">Generating next step…</span>
  `;
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial — generate next step from LLM
// ═══════════════════════════════════════════════════════════════════════════
async function generateNextStep() {
  if (tutorialState.isGenerating) return;
  tutorialState.isGenerating = true;
  showGenerating();

  // Reset tracking so stale annotation doesn't linger
  tutorialState.target   = { x: 0, y: 0, w: 0, h: 0 };
  tutorialState.current  = { x: 0, y: 0, w: 0, h: 0 };
  tutorialState.lastFoundBox = null;
  tutorialState.currentTarget = "";
  tutorialState.currentHint   = "";

  try {
    const res = await fetch("/generate-step", {
      method:  "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        topic:           tutorialState.topic,
        completed_steps: tutorialState.completedSteps,
      }),
    });

    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    if (data.is_complete) {
      speakText("Tutorial complete! You've covered all the steps.");
      stopTutorial();
      tutorialStepDisplay.innerHTML = '<span class="tutorial-step-placeholder" style="color:#22c55e;">Tutorial complete! Great job.</span>';
      return;
    }

    tutorialState.currentDescription = data.step_description;
    tutorialState.currentTarget      = data.target_object;
    tutorialState.currentHint        = data.hint || "";

    updateStepUI();
    speakText(data.step_description);
    statusEl.textContent = `Tracking: ${data.target_object}`;
  } catch (err) {
    tutorialStepDisplay.innerHTML = `<span class="tutorial-step-placeholder" style="color:#f87171;">Failed to generate step: ${escapeHtml(err.message)}</span>`;
    console.error("generateNextStep error:", err);
  } finally {
    tutorialState.isGenerating = false;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial — start / stop / next
// ═══════════════════════════════════════════════════════════════════════════
async function startTutorial() {
  const topic = tutorialTopicInput.value.trim();
  if (!topic) return;

  tutorialState.topic          = topic;
  tutorialState.completedSteps = [];
  tutorialState.stepNumber     = 1;
  tutorialState.isRunning      = true;

  btnTutorialStart.textContent = "Stop Tutorial";
  btnTutorialStart.classList.add("running");
  btnTutorialNext.disabled     = false;
  tutorialTopicInput.disabled  = true;

  startRenderLoop();
  startTrackingLoop();
  await generateNextStep();
}

function stopTutorial() {
  tutorialState.isRunning     = false;
  tutorialState.isGenerating  = false;

  if (tutorialState.analysisInterval) {
    clearInterval(tutorialState.analysisInterval);
    tutorialState.analysisInterval = null;
  }
  if (tutorialState.rafId) {
    cancelAnimationFrame(tutorialState.rafId);
    tutorialState.rafId = null;
  }

  tutorialCanvas.width  = tutorialCanvas.clientWidth;
  tutorialCanvas.height = tutorialCanvas.clientHeight;
  tutorialCtx.clearRect(0, 0, tutorialCanvas.width, tutorialCanvas.height);

  btnTutorialStart.textContent = "Start Tutorial";
  btnTutorialStart.classList.remove("running");
  btnTutorialNext.disabled     = true;
  tutorialTopicInput.disabled  = false;
  trackingDot.classList.remove("active");
  trackingStatus.textContent   = "Not tracking";

  tutorialStepDisplay.innerHTML = '<span class="tutorial-step-placeholder">Tutorial stopped. Type a topic and press Start to begin again.</span>';
}

async function nextStep() {
  if (!tutorialState.isRunning || tutorialState.isGenerating) return;

  // Archive the current step before generating the next
  if (tutorialState.currentDescription) {
    tutorialState.completedSteps.push(tutorialState.currentDescription);
  }
  tutorialState.stepNumber++;
  await generateNextStep();
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial — tracking loop (600ms Gemini poll)
// ═══════════════════════════════════════════════════════════════════════════
function startTrackingLoop() {
  if (tutorialState.analysisInterval) clearInterval(tutorialState.analysisInterval);

  const pollOnce = async () => {
    if (!tutorialState.isRunning || !state.stream) return;
    if (!tutorialState.currentTarget || tutorialState.isGenerating) return;

    // Capture frame from live video
    const offscreen  = document.createElement("canvas");
    offscreen.width  = video.videoWidth  || 640;
    offscreen.height = video.videoHeight || 480;
    offscreen.getContext("2d").drawImage(video, 0, 0);
    const base64 = offscreen.toDataURL("image/jpeg", 0.75).split(",")[1];

    try {
      const res = await fetch("/analyze-step", {
        method:  "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image:            base64,
          target_object:    tutorialState.currentTarget,
          step_instruction: tutorialState.currentDescription,
          hint:             tutorialState.currentHint,
          width:            offscreen.width,
          height:           offscreen.height,
        }),
      });

      if (!res.ok) return;

      const data = await res.json();

      if (data.found && data.box_2d) {
        const [ymin, xmin, ymax, xmax] = data.box_2d;
        if (xmax - xmin < 5 || ymax - ymin < 5) return;  // skip degenerate boxes

        const newBox = { x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin };
        tutorialState.target      = newBox;
        tutorialState.lastFoundBox = newBox;

        trackingDot.classList.add("active");
        trackingStatus.textContent = `Tracking: ${escapeHtml(data.label || tutorialState.currentTarget)}`;
      } else {
        // Hold last known position — don't reset target
        trackingDot.classList.remove("active");
        trackingStatus.textContent = "Searching…";
      }
    } catch (err) {
      console.warn("Tracking poll failed:", err.message);
    }
  };

  pollOnce();  // fire immediately, then on interval
  tutorialState.analysisInterval = setInterval(pollOnce, 600);
}

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial — render loop (RAF with lerp + canvas drawing)
// ═══════════════════════════════════════════════════════════════════════════
function startRenderLoop() {
  if (tutorialState.rafId) cancelAnimationFrame(tutorialState.rafId);

  const LERP = 0.12;
  const lerp  = (a, b, t) => a + (b - a) * t;

  function frame() {
    if (!tutorialState.isRunning) return;
    tutorialState.rafId = requestAnimationFrame(frame);

    // Keep canvas resolution in sync with CSS size
    if (tutorialCanvas.width  !== tutorialCanvas.clientWidth ||
        tutorialCanvas.height !== tutorialCanvas.clientHeight) {
      tutorialCanvas.width  = tutorialCanvas.clientWidth;
      tutorialCanvas.height = tutorialCanvas.clientHeight;
    }

    tutorialCtx.clearRect(0, 0, tutorialCanvas.width, tutorialCanvas.height);

    // Lerp toward target
    const tgt = tutorialState.target;
    const cur  = tutorialState.current;
    cur.x = lerp(cur.x, tgt.x, LERP);
    cur.y = lerp(cur.y, tgt.y, LERP);
    cur.w = lerp(cur.w, tgt.w, LERP);
    cur.h = lerp(cur.h, tgt.h, LERP);

    // Don't draw until a target has been established
    if (tgt.w < 5 && tgt.h < 5) return;

    // Convert 0-1000 coords → canvas pixels
    const cw = tutorialCanvas.width;
    const ch = tutorialCanvas.height;
    const px  = (cur.x / 1000) * cw;
    const py  = (cur.y / 1000) * ch;
    const pw  = (cur.w / 1000) * cw;
    const ph  = (cur.h / 1000) * ch;

    // Pulsing values via sine wave
    const t      = Date.now() / 800;
    const pulse  = 0.65 + 0.35 * Math.sin(t * Math.PI * 2);
    const glow   = 0.10 + 0.15 * Math.sin(t * Math.PI * 2 + 1);

    tutorialCtx.save();

    // Outer glow fill
    tutorialCtx.fillStyle = `rgba(56, 189, 248, ${glow})`;
    tutorialCtx.fillRect(px, py, pw, ph);

    // Corner brackets (cleaner AR look than full box)
    const bLen = Math.min(pw * 0.22, ph * 0.22, 24);
    tutorialCtx.strokeStyle = `rgba(56, 189, 248, ${pulse})`;
    tutorialCtx.lineWidth   = 2.5;
    tutorialCtx.lineCap     = "square";

    const drawCorner = (cx, cy, dx, dy) => {
      tutorialCtx.beginPath();
      tutorialCtx.moveTo(cx + dx * bLen, cy);
      tutorialCtx.lineTo(cx, cy);
      tutorialCtx.lineTo(cx, cy + dy * bLen);
      tutorialCtx.stroke();
    };
    drawCorner(px,      py,      1,  1);
    drawCorner(px + pw, py,     -1,  1);
    drawCorner(px,      py + ph, 1, -1);
    drawCorner(px + pw, py + ph,-1, -1);

    // Arrow from outside the box to its center
    const centerX  = px + pw / 2;
    const centerY  = py + ph / 2;
    const startX   = px - 32;
    const startY   = py - 32;
    const angle    = Math.atan2(centerY - startY, centerX - startX);
    const headLen  = 11;

    tutorialCtx.strokeStyle = `rgba(56, 189, 248, ${pulse * 0.9})`;
    tutorialCtx.lineWidth   = 2;
    tutorialCtx.lineCap     = "round";
    tutorialCtx.beginPath();
    tutorialCtx.moveTo(startX, startY);
    tutorialCtx.lineTo(centerX, centerY);
    tutorialCtx.stroke();

    // Arrowhead
    tutorialCtx.strokeStyle = `rgba(56, 189, 248, ${pulse})`;
    tutorialCtx.beginPath();
    tutorialCtx.moveTo(centerX, centerY);
    tutorialCtx.lineTo(centerX - headLen * Math.cos(angle - Math.PI / 7),
                       centerY - headLen * Math.sin(angle - Math.PI / 7));
    tutorialCtx.moveTo(centerX, centerY);
    tutorialCtx.lineTo(centerX - headLen * Math.cos(angle + Math.PI / 7),
                       centerY - headLen * Math.sin(angle + Math.PI / 7));
    tutorialCtx.stroke();

    // Label badge above the box
    const labelText = tutorialState.currentTarget || "";
    const fontSize  = Math.max(11, Math.min(14, pw * 0.09));
    tutorialCtx.font = `bold ${fontSize}px system-ui, sans-serif`;
    const labelW    = tutorialCtx.measureText(labelText).width;
    const labelH    = fontSize + 8;
    const labelX    = px + pw / 2 - labelW / 2 - 6;
    const labelY    = (py - labelH - 6 >= 0) ? py - labelH - 6 : py + ph + 6;

    tutorialCtx.fillStyle = "rgba(15, 23, 42, 0.85)";
    tutorialCtx.beginPath();
    tutorialCtx.roundRect(labelX, labelY, labelW + 12, labelH, 4);
    tutorialCtx.fill();

    tutorialCtx.fillStyle = `rgba(56, 189, 248, ${pulse})`;
    tutorialCtx.fillText(labelText, labelX + 6, labelY + fontSize);

    tutorialCtx.restore();
  }

  frame();
}

// ═══════════════════════════════════════════════════════════════════════════
// Camera
// ═══════════════════════════════════════════════════════════════════════════
async function initCamera() {
  try {
    state.stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width:      { ideal: 1280 },
        height:     { ideal: 720  },
        facingMode: "environment",
      },
      audio: false,
    });
    video.srcObject = state.stream;
    await video.play();

    btnCapture.disabled = false;
    btnVoice.disabled   = false;
    statusEl.textContent = "Camera ready — capture a frame to analyze.";
  } catch (err) {
    if (err.name === "NotAllowedError") {
      statusEl.textContent = "Camera permission denied. Allow access and refresh the page.";
    } else if (err.name === "NotFoundError") {
      statusEl.textContent = "No camera found on this device.";
    } else {
      statusEl.textContent = `Camera error: ${err.message}`;
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Frame capture
// ═══════════════════════════════════════════════════════════════════════════
function captureFrame() {
  if (!state.stream || state.isAnalyzing) return;

  const offscreen = document.createElement("canvas");
  offscreen.width  = video.videoWidth  || 640;
  offscreen.height = video.videoHeight || 480;
  const octx = offscreen.getContext("2d");
  octx.drawImage(video, 0, 0);

  const dataUrl = offscreen.toDataURL("image/jpeg", 0.85);
  const base64  = dataUrl.split(",")[1];

  // Show captured frame immediately in right panel
  capturedImg.src           = dataUrl;
  capturedImg.style.display = "block";
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  analyzeFrame(base64, offscreen.width, offscreen.height);
}

// ═══════════════════════════════════════════════════════════════════════════
// API call
// ═══════════════════════════════════════════════════════════════════════════
async function analyzeFrame(base64, origWidth, origHeight) {
  state.isAnalyzing   = true;
  btnCapture.disabled = true;

  const overlay = document.createElement("div");
  overlay.className = "loading-overlay";
  overlay.innerHTML = '<div class="spinner"></div><span>Analyzing…</span>';
  outputWrapper.appendChild(overlay);

  descBox.innerHTML = "<p>Analyzing…</p>";
  statusEl.textContent = "Sending frame to Gemini…";

  try {
    const res = await fetch("/analyze", {
      method:  "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        image:  base64,
        prompt: state.voiceTranscript,
        width:  origWidth,
        height: origHeight,
      }),
    });

    if (!res.ok) {
      const err = await res.json().catch(() => ({ detail: `HTTP ${res.status}` }));
      throw new Error(err.detail || `HTTP ${res.status}`);
    }

    const data = await res.json();
    drawAnnotations(data, origWidth, origHeight);
    statusEl.textContent = `${data.objects.length} object(s) detected.`;

  } catch (err) {
    descBox.innerHTML = `<p class="error-text">Error: ${err.message}</p>`;
    statusEl.textContent = "Analysis failed.";
  } finally {
    state.isAnalyzing       = false;
    btnCapture.disabled     = false;
    state.voiceTranscript   = "";
    transcriptEl.textContent = "";
    overlay.remove();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Canvas annotation drawing
// ═══════════════════════════════════════════════════════════════════════════
const BOX_COLORS = [
  "#3b82f6", "#ef4444", "#22c55e", "#f59e0b", "#a855f7",
  "#06b6d4", "#f97316", "#84cc16", "#ec4899", "#14b8a6",
];

function drawAnnotations(data, origWidth, origHeight) {
  // Sync canvas drawing buffer to CSS-rendered size
  canvas.width  = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  const scaleX = canvas.width  / origWidth;
  const scaleY = canvas.height / origHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  data.objects.forEach((obj, i) => {
    const [ymin_n, xmin_n, ymax_n, xmax_n] = obj.box_2d;

    // 0-1000 → 0-1 → original pixels → canvas CSS pixels
    const cx1 = (xmin_n / 1000) * origWidth  * scaleX;
    const cy1 = (ymin_n / 1000) * origHeight * scaleY;
    const cw  = ((xmax_n - xmin_n) / 1000) * origWidth  * scaleX;
    const ch  = ((ymax_n - ymin_n) / 1000) * origHeight * scaleY;

    const color = BOX_COLORS[i % BOX_COLORS.length];

    // Bounding box
    ctx.strokeStyle = color;
    ctx.lineWidth   = 2.5;
    ctx.strokeRect(cx1, cy1, cw, ch);

    // Label badge
    const label      = obj.label;
    const fontSize   = 12;
    ctx.font         = `bold ${fontSize}px system-ui`;
    const textW      = ctx.measureText(label).width;
    const badgeH     = fontSize + 6;
    const badgeY     = cy1 - badgeH - 2 >= 0 ? cy1 - badgeH - 2 : cy1 + 2;

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.roundRect(cx1, badgeY, textW + 10, badgeH, 3);
    ctx.fill();

    ctx.fillStyle = "#fff";
    ctx.fillText(label, cx1 + 5, badgeY + fontSize);
  });

  // Description
  descBox.innerHTML = `
    <p>${escapeHtml(data.description)}</p>
    <small>${data.objects.length} object(s) detected</small>
  `;

  if (!state.voiceMuted) speakText(data.description);
}

function escapeHtml(str) {
  return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
}

// ═══════════════════════════════════════════════════════════════════════════
// Voice input (Web Speech API — push-to-talk)
// ═══════════════════════════════════════════════════════════════════════════
function initVoiceInput() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) {
    btnVoice.disabled = true;
    btnVoice.title    = "Speech recognition not supported in this browser";
    return;
  }

  const rec          = new SR();
  rec.continuous     = false;
  rec.interimResults = true;
  rec.lang           = "en-US";
  state.recognition  = rec;

  rec.onresult = (event) => {
    let interim = "", final = "";
    for (const result of event.results) {
      if (result.isFinal) final   += result[0].transcript;
      else                interim += result[0].transcript;
    }
    transcriptEl.textContent = final || interim;
    if (final) {
      const trimmed = final.trim().toLowerCase();

      if (tutorialState.isRunning) {
        // "next" → advance step
        if (/\bnext\b/.test(trimmed)) {
          nextStep();
          state.voiceTranscript = "";
          return;
        }
      } else {
        // "start" → start the tutorial if there's a topic in the input
        if (/\bstart\b/.test(trimmed) && tutorialTopicInput.value.trim()) {
          startTutorial();
          state.voiceTranscript = "";
          return;
        }
        // Anything else → treat as the topic
        if (trimmed) {
          tutorialTopicInput.value = final.trim();
          btnTutorialStart.disabled = false;
          statusEl.textContent = `Topic set — press Start or say "start"`;
          state.voiceTranscript = "";
          return;
        }
      }

      state.voiceTranscript = final.trim();
    }
  };

  rec.onend = () => {
    btnVoice.textContent = "Hold to Speak";
    btnVoice.classList.remove("listening");
  };

  rec.onerror = (e) => {
    transcriptEl.textContent = `Recognition error: ${e.error}`;
    btnVoice.textContent     = "Hold to Speak";
    btnVoice.classList.remove("listening");
  };

  const startListening = (e) => {
    e.preventDefault();
    state.voiceTranscript    = "";
    transcriptEl.textContent = "Listening…";
    btnVoice.textContent     = "Recording…";
    btnVoice.classList.add("listening");
    try { rec.start(); } catch (_) { /* already running */ }
  };

  const stopListening = (e) => {
    e.preventDefault();
    rec.stop();
  };

  btnVoice.addEventListener("mousedown",  startListening);
  btnVoice.addEventListener("touchstart", startListening, { passive: false });
  btnVoice.addEventListener("mouseup",    stopListening);
  btnVoice.addEventListener("mouseleave", stopListening);
  btnVoice.addEventListener("touchend",   stopListening);
}

// ═══════════════════════════════════════════════════════════════════════════
// Voice output (SpeechSynthesis)
// ═══════════════════════════════════════════════════════════════════════════
function speakText(text) {
  if (!window.speechSynthesis || !text) return;
  window.speechSynthesis.cancel();

  const utter   = new SpeechSynthesisUtterance(text);
  utter.lang    = "en-US";
  utter.rate    = 1.0;
  utter.pitch   = 1.0;
  utter.volume  = 1.0;

  // Chrome workaround: resume if paused mid-utterance
  utter.onpause = () => {
    if (window.speechSynthesis.paused) window.speechSynthesis.resume();
  };

  const applyVoice = () => {
    const voices   = window.speechSynthesis.getVoices();
    const preferred = voices.find(v =>
      v.name.includes("Google US English") ||
      v.name === "Alex" ||
      (v.lang === "en-US" && v.localService)
    );
    if (preferred) utter.voice = preferred;
    window.speechSynthesis.speak(utter);
  };

  if (window.speechSynthesis.getVoices().length > 0) {
    applyVoice();
  } else {
    window.speechSynthesis.onvoiceschanged = () => {
      window.speechSynthesis.onvoiceschanged = null;
      applyVoice();
    };
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Mute toggle
// ═══════════════════════════════════════════════════════════════════════════
btnMute.addEventListener("click", () => {
  state.voiceMuted = !state.voiceMuted;
  if (state.voiceMuted) {
    window.speechSynthesis?.cancel();
    btnMute.textContent = "Voice: Off";
    btnMute.classList.add("muted");
  } else {
    btnMute.textContent = "Voice: On";
    btnMute.classList.remove("muted");
  }
});

// ═══════════════════════════════════════════════════════════════════════════
// Capture button
// ═══════════════════════════════════════════════════════════════════════════
btnCapture.addEventListener("click", captureFrame);

// ═══════════════════════════════════════════════════════════════════════════
// Tutorial buttons + spacebar shortcut
// ═══════════════════════════════════════════════════════════════════════════
// Enable Start whenever the input has text
tutorialTopicInput.addEventListener("input", (e) => {
  btnTutorialStart.disabled = !e.target.value.trim();
});
// Enter in input → start immediately
tutorialTopicInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && tutorialTopicInput.value.trim()) startTutorial();
});

btnTutorialStart.addEventListener("click", () => {
  if (tutorialState.isRunning) stopTutorial();
  else startTutorial();
});

btnTutorialNext.addEventListener("click", nextStep);

document.addEventListener("keydown", (e) => {
  if (e.code === "Space" && tutorialState.isRunning) {
    const tag = document.activeElement.tagName;
    if (tag !== "INPUT" && tag !== "SELECT" && tag !== "TEXTAREA") {
      e.preventDefault();
      nextStep();
    }
  }
});

// ═══════════════════════════════════════════════════════════════════════════
// Boot
// ═══════════════════════════════════════════════════════════════════════════
document.addEventListener("DOMContentLoaded", async () => {
  await initCamera();
  initVoiceInput();
});
</script>
</body>
</html>
